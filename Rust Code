use std::env;
use std::fs;
use std::path::Path;
use std::time::Instant;

/// Recursively computes directory size (follows macOS file system rules)
fn get_size(path: &Path) -> u64 {
    if path.is_file() {
        return path.metadata().map(|m| m.len()).unwrap_or(0);
    }
    let mut size = 0;
    if let Ok(entries) = fs::read_dir(path) {
        for entry in entries.flatten() {
            size += get_size(&entry.path());
        }
    }
    size
}

/// Pretty-prints bytes into human-readable macOS style (KB, MB, GB)
fn format_size(bytes: u64) -> String {
    const KB: u64 = 1000;
    const MB: u64 = KB * 1000;
    const GB: u64 = MB * 1000;

    if bytes >= GB {
        format!("{:.2} GB", bytes as f64 / GB as f64)
    } else if bytes >= MB {
        format!("{:.2} MB", bytes as f64 / MB as f64)
    } else if bytes >= KB {
        format!("{:.2} KB", bytes as f64 / KB as f64)
    } else {
        format!("{} B", bytes)
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <directory_path>", args[0]);
        return;
    }

    let dir = Path::new(&args[1]);
    if !dir.is_dir() {
        eprintln!("{} is not a valid directory.", dir.display());
        return;
    }

    let start = Instant::now();
    let mut usage: Vec<(String, u64)> = Vec::new();

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            let size = get_size(&path);
            usage.push((path.display().to_string(), size));
        }
    }

    usage.sort_by(|a, b| b.1.cmp(&a.1));

    println!("Disk usage for: {}\n", dir.display());
    for (path, size) in usage {
        println!("{:<70} {:>10}", path, format_size(size));
    }

    println!("\nCompleted in {:.2?}", start.elapsed());

}
